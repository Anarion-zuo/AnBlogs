# Zookeeper

本文是阅读Zookeeper论文的笔记，属于6.824课程assignment的一部分，可以在课程网站上下载pdf。

## 一致性

Linearizability：集群好像表现为一台机器，具体为：

- 每个指令按照一定顺序，先后依次执行
- 顺序应满足，指令A执行完成后指令B才从客户端发出，则指令执行顺序一定为先A后B
- 读操作一定可以看到最近一次写操作的结果

## 读写分离和不强一致性

写操作完成之后，不是所有节点都同步了状态，部分节点还未同步状态。

此时不能从任意节点读取，最保险的方法是从主节点读取。把读操作和写操作当作相同操作来看待，同等地插入日志。读操作对应的日志同步成功后，再令读操作返回。这样很简单，但是效率欠缺。

Zookeeper实现了读写分离机制，但是没有保证强一致性。写操作全部在主节点执行，读操作保证能读到本客户端最近一次写的结果，但是不一定能读到其他客户端在此之前执行的写操作结果。

实现的方法是，每个客户端每次进行写操作时，服务端都返回写操作提交的位置。客户端维持一个最近一次写操作的位置，每次读操作都携带这个id，令服务端等待这个写操作结果同步完成后再返回读结果。

这样稍微弱一些的一致性，可以理解为，物理上不同客户端请求顺序不是Zookeeper表现的请求顺序。即便客户端之间可以通信，可以确保A发送完之后B才发送，也不一定在Zookeeper获得这样的效果。

## 数据对象和服务

和Lab3类似，Zookeeper提供的服务是，由一个同步日志维持的数据库状态。Lab3实现的是KeyValue存储，存的是一个类似map的东西。Zookeeper存的是一个树结构，提供增删改查API。

要定位一个树中的节点，用Unix风格的路径名称，比如/a/b/c/d。所有api都要接受一个路径名称作为参数，比如：

```python3
create(path, data, flags)
delete(path, version)
exists(path, watch)
getData(path, watch)
setData(path, data, version)
getChildren(path, watch)
sync(path)
```

用这些API实现对树结构的更改，用树结构维持逻辑上的记录，用ZAB协议进行主从复制，这就是Zookeeper提供的服务。

Zookeeper实现watch功能，当客户端指定要watch一个节点，当这个节点的状态发生改变时，客户端会收到一个通知。通知是一次性的，即多次改变只会收到一次通知。通知也不包含和节点有关的具体信息，需要客户端自己使用读操作获取。

## 常见设计

### 用作公共配置信息存储

最直接的用途是分布式信息存储，虽然树节点能存储的空间有上限，而且不是为存储大量信息而设计的，但是也可以用作小规模信息的存储。

使用上述API可以直接进行简单的增删改查，也可以指定watch一个节点。一个被给定客户端watch的节点状态发生改变时，客户端会收到一个通知。这是一种观察者模式。

### 用作简单的锁

使用一个ready节点，作为数据库状态是否可读的表示。写事务在改变数据库状态更新前，删除ready节点，更新之后恢复ready节点。读事务执行之前先检查ready节点是否存在，不存在则等待ready节点恢复。

```text
delete(ready)
// write
create(ready)

exists(ready, true)
// wait for ready
// read
```

等待ready节点恢复，就是等待通知的过程。ready节点从不存在变为存在时，客户端就会收到通知，然后继续执行。

如果读操作看到ready节点存在并开始读取，读取还没执行完，写操作就删除了ready节点并开始写。客户端不会读到中间状态，分为以下几种情况。

若写操作发生在读操作之后，或exists之前，则没有任何影响。若写操作发生在读操作之前、exists操作之后，则服务端先发送关于ready节点的更新通知，再进行写操作，这是Zookeeper指令序列化要求的。即在每次写操作之前，如果产生了对于部分节点的通知，就先发送这些通知。

考虑两次读的场景，在读`f1, f2`之间，另一个客户端发送`delete`指令准备进行写操作。此时，`ready`状态改变的通知在两次读之间到达。由于Zookeeper的规定，通知一定在写操作之前到达。收到通知后，客户端必须重新执行已经执行过的`read(f1)`操作，即重新执行整个流程。

```c
exists(ready, true)
read(f1)
// ...
read(f2)

delete(ready)
write(f1)
write(f2)
create(ready)
// ...
```

### 原子自增

`++`要先读取对象，在写入对象，中间存在空挡，可能会和其他操作交织。使用类似TestAndSet方式进行操作。读时拿到一个版本号，写时携带这个版本号。服务端如果发现版本号不一致，则不进行操作。如果版本号未发生改变，说明没有其他操作和本操作交织，则执行成功，不再重复尝试。

```python
while True:
    x, version = getData(counter)
    if setData(counter, x + 1, version):
        break
```

### 用作竞争小的锁

简单的锁存在问题，当锁被释放时，所有客户端都收到通知，然后同时请求服务端，导致严重竞争。最好实现每次释放锁时只唤醒一个客户端。

利用SEQUENTIAL创建节点，令节点具有自增id。每次加锁时创建节点，并验证自己创建的节点是否为当前所有表示锁的节点中的最小节点。如果是，则加锁成功，否则等待比自己小的最大节点被删除。等待也是利用watch机制，当这个节点被删除时，说明自己得到了锁。

### 和一般操作系统锁的区别

用于实现锁的节点都是Ephemeral的，生命周期由会话控制。如果服务端认为和客户端连接中断了，就会删除相应节点，即放开锁。故锁状态不是完整维持的，可能出现中间状态。

锁也是可重入的，同一个客户端反复加锁不会和自己死锁。

## 用作读写锁

将竞争小的锁方式稍微更改，就可以得到读写锁。令读、写锁分别在两个父节点上创建，通过一个自增源头获得id，加读锁时，等待比自己小的最大写锁节点被删除。

删除一个写锁节点时，可能有多个读锁节点被唤醒，这就是我们想要的。

### 用作分区登记

集群中要维持几个分区，用一个节点的子节点集合来表示各个分区的节点集合。利用Zookeeper的Ephemeral模式，令节点在会话结束之后就自动删除，实现自动化的分区登记。

## 同步机制

### 共识算法

### 事务机制
