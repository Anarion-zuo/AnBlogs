# Zookeeper

本文是阅读Zookeeper论文的笔记，属于6.824课程assignment的一部分，可以在课程网站上下载pdf。

## 数据对象和服务

和Lab3类似，Zookeeper提供的服务是，由一个同步日志维持的数据库状态。Lab3实现的是KeyValue存储，存的是一个类似map的东西。Zookeeper存的是一个树结构，提供增删改查API。

要定位一个树中的节点，用Unix风格的路径名称，比如/a/b/c/d。所有api都要接受一个路径名称作为参数，比如：

```
create(path, data, flags)
delete(path, version)
exists(path, watch)
getData(path, watch)
setData(path, data, version)
getChildren(path, watch)
sync(path)
```

用这些API实现对树结构的更改，用树结构维持逻辑上的记录，用ZAB协议进行主从复制，这就是Zookeeper提供的服务。

Zookeeper实现watch功能，当客户端指定要watch一个节点，当这个节点的状态发生改变时，客户端会收到一个通知。通知是一次性的，即多次改变只会收到一次通知。通知也不包含和节点有关的具体信息，需要客户端自己使用读操作获取。

## 常见设计

### 用作公共配置信息存储

最直接的用途是分布式信息存储，虽然树节点能存储的空间有上限，而且不是为存储大量信息而设计的，但是也可以用作小规模信息的存储。

使用上述API可以直接进行简单的增删改查，也可以指定watch一个节点。一个被给定客户端watch的节点状态发生改变时，客户端会收到一个通知。这是一种观察者模式。

### 用作简单的锁

使用一个ready节点，作为数据库状态是否可读的表示。写事务在改变数据库状态更新前，删除ready节点，更新之后恢复ready节点。读事务执行之前先检查ready节点是否存在，不存在则等待ready节点恢复。

```
delete(ready)
// write
create(ready)

exists(ready, true)
// wait for ready
// read
```

等待ready节点恢复，就是等待通知的过程。ready节点从不存在变为存在时，客户端就会收到通知，然后继续执行。

如果读操作看到ready节点存在并开始读取，读取还没执行完，写操作就删除了ready节点并开始写。客户端不会读到中间状态，分为以下几种情况。

若写操作发生在读操作之后，或exists之前，则没有任何影响。若写操作发生在读操作之前、exists操作之后，则服务端先发送关于ready节点的更新通知，再发送读操作的结果，这是Zookeeper指令序列化要求的。即在每次读操作之前，如果产生了对于部分节点的通知，就先发送这些通知。

### 用作竞争小的锁

简单的锁存在问题，当锁被释放时，所有客户端都收到通知，然后同时请求服务端，导致严重竞争。最好实现每次释放锁时只唤醒一个客户端。

利用SEQUENTIAL创建节点，令节点具有自增id。每次加锁时创建节点，并验证自己创建的节点是否为当前所有表示锁的节点中的最小节点。如果是，则加锁成功，否则等待比自己小的最大节点被删除。等待也是利用watch机制，当这个节点被删除时，说明自己得到了锁。

## 用作读写锁

将竞争小的锁方式稍微更改，就可以得到读写锁。令读、写锁分别在两个父节点上创建，通过一个自增源头获得id，加读锁时，等待比自己小的最大写锁节点被删除。

删除一个写锁节点时，可能有多个读锁节点被唤醒，这就是我们想要的。

### 用作分区登记

集群中要维持几个分区，用一个节点的子节点集合来表示各个分区的节点集合。利用Zookeeper的Ephemeral模式，令节点在会话结束之后就自动删除，实现自动化的分区登记。

## 同步机制

### 共识算法

### 事务机制
