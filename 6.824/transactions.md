# 分布式事务

实现跨机器的原子操作/ACID。

```python
begin
commit
abort
```

## 先后原子性

Before-or-after原子性，即先后原子性，保证，在调用者看来，被调用的并发流程的执行效果，总是和几个流程串行执行的效果相同。

## 加锁机制

### 简单加锁

每次事务开始时，一次性加事务需要的所有锁。

这样的加锁方法可以保证正确性，即保证先后原子性。但可能放弃部分并发机会，即对部分对象的访问只是在很短时间内，但却把锁从头到尾维持。

### 两阶段锁

第一次要调用一个资源的时候就加锁，之后再调用这个资源不用重复加锁，加读写锁。

所有锁都加完了之后才能开始释放锁，之后不再需要某资源时才释放该资源的锁。

- 用之前先加锁
- 锁维持至事务结束，提交或回滚
- 加锁顺序不一致导致死锁
  - 运行时间太长就认为死锁
  - 等待图
  - 事务开始时获得所有锁

## 隔离机制

两个事务$T_1,T_2$并发执行，一定和串行执行等价，即结果总是和$T_1 > T_2$或$T_2 > T_1$相同。这称为Serializability。

Serializability不如Linearizability强，后者保证执行的顺序和物理上请求的顺序相同，前者没有顺序的保证。

## 两阶段提交

- 用之前先加锁
- 写操作记录在日志，而不是直接写在数据库上
- 执行完成后，主线程产生prepare信号，让事务准备
- 事务准备好后，主线程发射commit信号执行提交
- 执行时一次性执行所有写操作，然后释放锁

主线程用来调度，帮助判断事务之间是否有冲突。有冲突时，事务回滚，令其他事务能继续执行。

prepare信号产生之后，必须持久化这个状态。恢复之后不再重新产生一次。
