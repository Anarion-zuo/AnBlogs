# Spanner

## 组织方式

实现跨数据中心的同步，每个数据中心都有一个shard，由来自不同数据中心的shard集成一个paxos group，实现同步。客户端选择距离自己最近的服务端进行通信。

## 服务

- 读操作能读到最近执行的写操作结果
- 实现不同shard之间的事务
- 事务serializable

### 写事务

第一次读或写操作触发对于特定对象的锁，以两阶段锁形式管理锁。写操作先发送给一个coordinator，coordinator再发送给对应的shard。shard内部的读写都是用paxos。

提交前的写操作都是以prepare形式准备，提交commit时一次性写入，然后释放所有锁。

## 只读事务

只读事务，客户端向距离自己最近的shard要数据，不加锁，没有两阶段提交。

规定：

- Serializable：事务执行等价于它们以某种顺序串行执行
- 外部一致性：T1提交在T2启动之前，则T2一定能读取到T1的写操作结果
  - 外部一致性可以看作事务层面上的Linearizability

### 不正确的实现方式

考虑3个事务，执行操作按如下顺序，它们总是尝试读取最新提交的数据。

```text
T1: Wx Wy C
T2:              Wx Wy C
T3:          Rx          Ry
```

T3两次读，若总是读最新提交的数据，则分别读到来自两个不同的事务的数据。这是不可接受的。

### 数据库喜欢的快照隔离机制

- 每个事务都具有一个timestamp时间戳
  - 只读事务是事务启动时候给的
  - 会写的事务是提交时候给的
- 所有操作都是按照timestamp顺序执行的
- 每个节点都保存不同timestamp的版本

考虑原来的3个事务，写事务timestamp在提交时确定，读事务的在启动时确定。T3应读取到T1的结果，而不是T2的结果。

```text
T1@10: Wx Wy C10
T2@20:              Wx Wy C20
T3@15:          Rx             Ry
```

要实现又读又写的事务，可以给事务给两个timestamp，读用一个写用另一个。

可能出现同步未完成情况，即可能读到不是事务启动时最新的写操作结果。解决方法是，等待一个比自己的timestamp更大的写timestamp出现时，再进行读操作。

如果T3读timestamp太大，则等待时间就会长一点。如果太小，小于最近写timestamp，则说明timestamp机制有错，破坏了外部一致性，即timestamp的大小不能反映执行顺序。

### 全局Timestamp生成机制

难点有一下几点：

- 震荡电路实现的时钟总是想偏移，用原子钟、GPS始终解决这个问题
- 但是网络等还是会让服务器无法拿到最准确的时间戳

要解决这个问题，就是让timestamp生成机制返回一个区间，而不是一个时间点。有几点规定：

- 区间右边界的值一定大于真实时间，左边界值小于等于真实时间
- 写事务提交应该被推迟至之前事务的所有右边界的最大值之后，即保证之前所有事务都已经提交之后
- 读操作取右边界作为逻辑上的timestamp

## 总结

读写事务使用两阶段锁和两阶段提交，分别保证线程安全和执行顺序，即顺序原子性。

只读事务使用多版本快照隔离机制保证顺序原子性，使用时间戳机制保证外部一致性external consistency，其中为了实现一个合理的时间戳分配机制，分配应返回一个区间而不是单个时间点。
